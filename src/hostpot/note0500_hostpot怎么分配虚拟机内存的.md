
参考文档
https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1

## 2.5。运行时数据区
Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在Java虚拟机启动时创建的，仅在Java虚拟机退出时销毁。其他数据区域是每个线程。线程数据区域是在线程退出时创建和销毁线程时创建的。

## 2.5.1。该pc注册
Java虚拟机可以同时支持许多执行线程（JLS§17）。每个Java虚拟机线程都有自己的 pc（程序计数器）寄存器。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法（第2.6节）。如果不是该方法 native，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前正在执行该方法native，则Java虚拟机pc 寄存器的值未定义。Java虚拟机pcregister足够宽，可以returnAddress在特定平台上保存或指向本机指针。

## 2.5.2。Java虚拟机堆栈
每个Java虚拟机线程都有一个私有Java虚拟机堆栈，**与线程同时创建。**Java虚拟机堆栈存储帧（第2.6节）。Java虚拟机堆栈类似于传统语言的堆栈，例如C：它保存局部变量和部分结果，并在方法调用和返回中起作用。由于除了推送和弹出帧之外，永远不会直接操作Java虚拟机堆栈，因此可以对堆进行堆分配。Java虚拟机堆栈的内存不需要是连续的。

在第一版中的Java ®虚拟机规范，Java虚拟机堆被称为Java堆栈。

此规范允许Java虚拟机堆栈具有固定大小或根据计算的需要动态扩展和收缩。如果Java虚拟机堆栈具有固定大小，则可以在创建该堆栈时独立选择每个Java虚拟机堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对Java虚拟机堆栈的初始大小的控制，以及在动态扩展或收缩Java虚拟机堆栈的情况下，控制最大和最小大小。

以下异常条件与Java虚拟机堆栈相关联：

如果线程中的计算需要比允许的更大的Java虚拟机堆栈，则Java虚拟机会抛出一个StackOverflowError。

如果可以动态扩展Java虚拟机堆栈，并且尝试进行扩展但可以使内存不足以实现扩展，或者可以使内存不足以为新线程创建初始Java虚拟机堆栈，则Java Virtual机器抛出一个OutOfMemoryError。

> 是与线程同时创建的 主线程 （初始化虚拟机的时候） 和 子线程 （运行时）

##  2.5.3。堆
Java虚拟机具有在所有Java虚拟机线程之间共享的堆。堆是运行时数据区，从中分配所有类实例和数组的内存。

**堆是在虚拟机启动时创建的。**对象的堆存储由自动存储管理系统（称为垃圾收集器）回收 ; 对象永远不会被显式释放。Java虚拟机假设没有特定类型的自动存储管理系统，可以根据实现者的系统要求选择存储管理技术。堆可以具有固定大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的堆，则可以收缩。堆的内存不需要是连续的。

Java虚拟机实现可以为程序员或用户提供对堆的初始大小的控制，以及如果可以动态扩展或收缩堆，则控制最大和最小堆大小。

以下异常情况与堆相关联：

如果计算需要的堆量超过自动存储管理系统可用的堆，则Java虚拟机会抛出一个 OutOfMemoryError。

> 堆是在虚拟机初始化的时候启动的时候创建的

##  2.5.4。方法区
Java虚拟机具有在所有Java虚拟机线程之间共享的方法区域。方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段。它存储每类结构，例如运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法（第2.9节）。

**方法区域是在虚拟机启动时创建的**  虽然方法区域在逻辑上是堆的一部分，但是简单的实现可能选择不垃圾收集或压缩它。本规范未规定方法区域的位置或用于管理编译代码的策略。方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以缩小方法区域。方法区域的内存不需要是连续的。

Java虚拟机实现可以提供程序员或用户对方法区域的初始大小的控制，以及在变大小方法区域的情况下，控制最大和最小方法区域大小。

以下异常条件与方法区域相关联：

如果方法区域中的内存无法满足分配请求，则Java虚拟机会抛出一个OutOfMemoryError。

## 2.5.5。运行时常量池
甲运行时间常数池是的每个类或每个接口的运行时表示constant_pool在表class文件（§4.4）。它包含几种常量，从编译时已知的数字文字到必须在运行时解析的方法和字段引用。运行时常量池提供类似于传统编程语言的符号表的功能，尽管它包含比典型符号表更宽范围的数据。

每个运行时常量池都是从Java虚拟机的方法区域（第2.5.4节）中分配的。当Java虚拟机创建类或接口（第5.3节）时，将构造类或接口的运行时常量池。

以下异常条件与类或接口的运行时常量池的构造相关联：

在创建类或接口时，如果运行时常量池的构造需要的内存比Java虚拟机的方法区域中可用的内存多，则Java虚拟机会抛出一个OutOfMemoryError。

有关 构造运行时常量池的信息，请参见§5（加载，链接和初始化）。

## 2.5.6。本机方法堆栈
Java虚拟机的实现可以使用常规堆栈（俗称“**C堆栈**”）来支持native方法（用Java编程语言以外的语言编写的方法）。本机方法堆栈也可以通过以诸如C语言的Java虚拟机的指令集的解释器的实现来使用。无法加载native 方法并且本身不依赖于传统堆栈的Java虚拟机实现不需要提供本机方法堆栈。如果提供，则通常在创建每个线程时为每个线程分配本机方法堆栈。

此规范允许本机方法堆栈具有固定大小或根据计算的需要动态扩展和收缩。如果本机方法堆栈具有固定大小，则可以在创建该堆栈时独立地选择每个本机方法堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对本机方法堆栈的初始大小的控制，以及在不同大小的本机方法堆栈的情况下，控制最大和最小方法堆栈大小。

以下异常条件与本机方法堆栈相关联：

如果线程中的计算需要比允许的更大的本机方法堆栈，则Java虚拟机会抛出一个StackOverflowError。

如果可以动态扩展本机方法堆栈并尝试进行本机方法堆栈扩展，但可以使内存不足，或者如果没有足够的内存可用于为新线程创建初始本机方法堆栈，则Java虚拟机会抛出OutOfMemoryError。