
# 第5章加载，链接和初始化

Java虚拟机动态加载，链接和初始化类和接口。加载是查找具有特定名称的类或接口类型的二进制表示并从该二进制表示创建类或接口的过程。链接是获取类或接口并将其组合到Java虚拟机的运行时状态以便可以执行的过程。类或接口的初始化包括执行类或接口初始化方法<clinit>（第2.9.2节）。

在本章中，第 5.1节描述了Java虚拟机如何从类或接口的二进制表示中派生符号引用。§5.2解释了如何首先由Java虚拟机启动加载，链接和初始化的过程。§5.3指定类加载器如何加载类和接口的二进制表示以及如何创建类和接口。链接在第5.4节中描述 。§5.5详细说明了如何初始化类和接口。§5.6 介绍了绑定本机方法的概念。最后， §5.7描述了Java虚拟机何时退出。

## 5.1。运行时常量池
Java虚拟机维护每类型常量池（第2.5.5节），这是一种运行时数据结构，它服务于传统编程语言实现的符号表的许多目的。

## 5.2。Java虚拟机启动
Java虚拟机通过使用引导类加载器（第5.3.1节）或用户定义的类加载器（第5.3.2节）创建初始类或接口来启动。然后，Java虚拟机链接初始类或接口，初始化它并调用该public static方法void main(String[])。调用此方法会驱动所有进一步的执行。构成该main 方法的Java虚拟机指令的执行可以导致附加类和接口的链接（并因此创建），以及其他方法的调用。

## 5.3。创作和加载
由名称表示的类或接口C的创建N包括Java虚拟机的方法区域（第2.5.4节）中C的特定于实现的内部表示的构造。类或接口创建由另一个类或接口D触发，它通过其运行时常量池引用C. 类或接口创建也可能由某些Java SE Platform类库（第2.12节）中的D调用方法（如反射）触发。

有两种类加载器：Java虚拟机提供的引导类加载器和用户定义的类加载器。每个用户定义的类加载器都是抽象类的子类的实例 ClassLoader。应用程序使用用户定义的类加载器，以扩展Java虚拟机动态加载的方式，从而创建类。用户定义的类加载器可用于创建源自用户定义的源的类。例如，可以通过网络下载类，即时生成或从加密文件中提取类。

### 5.3.1。使用Bootstrap类加载器加载
以下步骤用于加载，从而创建使用引导类加载器 表示的非阵列类或接口C.N

首先，Java虚拟机确定引导类加载器是否已被记录为表示的类或接口的初始加载器N。如果是这样，则此类或接口为C，并且不需要创建类。

否则，Java虚拟机将参数传递N给引导类加载器上的方法的调用，以依赖于平台的方式搜索C的声称表示。通常，将使用分层文件系统中的文件来表示类或接口，并且将在文件的路径名中对类或接口的名称进行编码。

### 5.3.2。使用用户定义的类加载器加载
下面的步骤用于加载，并由此创建非数组类或接口Ç表示为N使用用户定义的类装载程序L。

首先，Java虚拟机确定是否L已将其记录为表示的类或接口的初始加载器N。如果是这样，则此类或接口为 C，并且不需要创建类。

否则，Java虚拟机调用上。通过调用返回的值是所创建的类或接口Ç。然后Java虚拟机记录它是C （第5.3.4节）的初始加载器。本节的其余部分将更详细地介绍此过程。 loadClass(N)LL

### 5.3.3。创建数组类
下面的步骤被用来创建阵列类Ç表示为N使用的类加载器 L。类加载器L可以是引导类加载器或用户定义的类加载器。

如果L已经记录为具有相同组件类型的数组类的初始加载器N，则该类为C，并且不需要创建数组类。

否则，执行以下步骤来创建C：

如果组件类型是reference类型，则使用类加载器递归地应用本节（第5.3节）的算法L以便加载并由此创建C的组件类型。

Java虚拟机使用指示的组件类型和维数创建一个新的数组类。

如果组件类型是reference类型，则C被标记为已由组件类型的定义类加载器定义。否则，C被标记为已由引导类加载器定义。

无论如何，Java虚拟机然后记录它L是C的启动加载器 （§5.3.4）。

如果组件类型是reference类型，则数组类的可访问性由其组件类型的可访问性决定。否则，数组类的可访问性是public。

### 5.3.4。加载约束
在班级装载机的存在下确保类型安全连接需要特别小心。当两个不同的类加载器启动加载由类表示的类或接口时N，该名称N可能表示每个加载器中的不同类或接口。

当一个类或接口 Ç = ，使得一个符号引用到另一个类或接口的一个字段或方法d = ， 中，符号引用包括描述符指定字段的类型，或者返回与参数类型的方法的。在加载时和加载时，字段或方法描述符中提到的任何类型名称都必须表示相同的类或接口 。 <N1L1><N2L2>NL1L2

### 5.3.5。从class文件表示中 派生类
以下步骤用于从文件格式的声称表示中使用加载器表示Class非阵列类或接口C的对象。 NLclass

首先，Java虚拟机确定它是否已经记录了 L表示的类或接口的启动加载器 N。如果是这样，则此创建尝试无效并且加载会抛出a LinkageError。

否则，Java虚拟机会尝试解析声称的表示。然而，所声称的表示实际上可能不是C的有效表示。

此加载阶段必须检测以下错误：


### 5.3.6。模块和图层
Java虚拟机支持将类和接口组织到模块中。模块中的类或接口C的成员资格M用于控制除（§5.4.4）之外的模块中的类和接口对C的访问。


## 5.4。链接
链接类或接口涉及验证和准备该类或接口，其直接超类，其直接超接口及其元素类型（如果它是数组类型），如果需要。类或接口中符号引用的解析是链接的可选部分。

只要维护了以下所有属性，此规范允许实现灵活性，以便何时发生链接活动（以及由于递归，加载）。

类或接口在链接之前已完全加载。

在初始化之前，类或接口已完全验证并准备好。

在链接期间检测到的错误被抛出到程序中的某个点，程序可能会直接或间接地需要链接到错误中涉及的类或接口。

例如，Java虚拟机实现可以选择在使用它时分别解析类或接口中的每个符号引用（“延迟”或“延迟”解析），或者在验证类时立即解析它们（ “渴望”或“静态”决议）。这意味着在一些实现中，在初始化类或接口之后，解析过程可以继续。无论采用哪种策略，在解析期间检测到的任何错误都必须抛出到程序中（直接或间接）使用对类或接口的符号引用的位置。

因为链接涉及新数据结构的分配，所以它可能会失败OutOfMemoryError。

## 5.5。初始化
初始化一个类或接口包括执行其类或接口初始化方法（的 §2.9.2）。

只有以下结果才能初始化 类或接口C：

的Java虚拟机指令的任何一个的执行新的， getstatic，putstatic，或invokestatic引用Ç （§ 新， § getstatic， § putstatic， 第invokestatic）。

在执行新指令时，要初始化的类是指令引用的类。

在执行getstatic，putstatic或invokestatic 指令时，要初始化的类或接口是声明已解析字段或方法的类或接口。

第一次调用java.lang.invoke.MethodHandle实例，它是方法句柄解析（第5.4.3.5节）的结果，用于类型2（REF_getStatic），4（REF_putStatic），6（REF_invokeStatic）或8（REF_newInvokeSpecial）的方法句柄。

这意味着类Bootstrap方法是在引导方法被调用的初始化invokedynamic 指令（第invokedynamic），作为呼叫现场符的持续决议的一部分。

在类库（第2.12节）中调用某些反射方法，例如，在类Class或包中java.lang.reflect。

如果C是一个类，则初始化其子类之一。

如果C是声明abstract非非static方法的接口，则直接或间接实现C的类的初始化。

它被指定为Java虚拟机启动时的初始类或接口（第5.2节）。

在初始化之前，必须链接一个类或接口，即验证，准备和可选地解析。

由于Java虚拟机是多线程的，因此初始化类或接口需要仔细同步，因为某些其他线程可能正在尝试同时初始化相同的类或接口。作为该类或接口的初始化的一部分，还可以递归地请求类或接口的初始化。Java虚拟机的实现负责通过使用以下过程来处理同步和递归初始化。它假定该Class对象已经过验证和准备，并且该 对象已经过验证 Class object包含指示以下四种情况之一的状态：

此Class对象已经过验证和准备但未初始化。

该Class对象由某个特定线程初始化。

此Class对象已完全初始化并可供使用。

此Class对象处于错误状态，可能是因为尝试初始化并失败。