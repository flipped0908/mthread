Disruptor是一款高性能的有界内存队列，目前应用非常广泛，

Log4j2、Spring Messaging、HBase、Storm都用到了 Disruptor，那Disruptor的性能为什么这么高呢?

Disruptor项目团队曾经写过一篇论文，详细解释了其原因，可以总结为如 下:  
1. 内存分配更加合理，使用RingBuffer数据结构，数组元素在初始化时一次性全部创建，提升缓存命中率;对象循环利用， 避免频繁GC。  
2. 能够避免伪共享，提升缓存利用率。  
3. 采用无锁算法，避免频繁加锁、解锁的性能消耗。  
4. 支持批量消费，消费者可以无锁方式消费多个消息。  


Disruptor的使用比Java SDK提供BlockingQueue要复杂一些，但 是总体思路还是一致的  

Java SDK中ArrayBlockingQueue使用数组作为底层的数据存储，而Disruptor是使用RingBuffer作为数据存储  


## 程序的局部性原理

程序的局部性原理指的是在一段时间内程序的执行会 限定在一个局部范围内 

一个是时间局部性，另一个是空间局部性。时间局部性指的 是程序中的某条指令一旦被执行，
不久之后这条指令很可能再次被执行;如果某条数据被访问，不久之后这条数据很可能再次 被访问。
而空间局部性是指某块内存一旦被访问，不久之后这块内存附近的内存也很可能被访问



## 如何避免“伪共享”

伪共享和CPU内部的Cache有关，Cache内部是按照缓存行(Cache Line)管理的，缓存行的大小通常是64个字节

简单来讲，伪共享指的是由于共享缓存行导致缓存无效的场景。

每个变量独占一个缓存行、不共享缓存行就可以了，具体技术是缓存行填充




## Disruptor中的无锁算法


对于入队操作，最关键的要求是不能覆盖没有消费的元素;对于出队操作，最关键的要求是不能读取没有写入的元素，
所以 Disruptor中也一定会维护类似出队索引和入队索引这样两个关键变量。Disruptor中的RingBuffer维护了入队索引，
但是并没有 维护出队索引，这是因为在Disruptor中多个消费者可以同时消费，每个消费者都会有一个出队索引，
所以RingBuffer的出队索 引是所有消费者里面最小的那一个。


下面是Disruptor生产者入队操作的核心代码，看上去很复杂，其实逻辑很简单:如果没有足够的空余位置，就出让CPU使用 权，
然后重新计算;反之则用CAS设置入队索引。



## 总结
Disruptor在优化并发性能方面可谓是做到了极致，优化的思路大体是两个方面，
一个是利用无锁算法避免锁的争用，
另外一个 则是将硬件(CPU)的性能发挥到极致。尤其是后者，在Java领域基本上属于经典之作了。


发挥硬件的能力一般是C这种面向硬件的语言常干的事儿，C语言领域经常通过调整内存布局优化内存占用，而Java领域则用
的很少，原因在于Java可以智能地优化内存布局，内存布局对Java程序员的透明的。这种智能的优化大部分场景是很友好 的，


但是如果你想通过填充方式避免伪共享就必须绕过这种优化，关于这方面Disruptor提供了经典的实现，你可以参考。
由于伪共享问题如此重要，

所以Java也开始重视它了，比如Java 8中，提供了避免伪共享的注解:@sun.misc.Contended， 
通过这个注解就能轻松避免伪共享(需要设置JVM参数-XX:-RestrictContended)。

不过避免伪共享是以牺牲内存为代价的， 所以具体使用的时候还是需要仔细斟酌。




























