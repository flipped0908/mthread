并发编程领域的问题总结为三个核心问题:分工、同步和互斥。其中，同步和互斥相关问题更多地源自微观，而分 工问题则是源自宏观。
我们解决问题，往往都是从宏观入手，在编程领域，软件的设计过程也是先从概要设计开始，而后才进 行详细设计。
同样，解决并发编程问题，首要问题也是解决宏观的分工问题。  


解决分工问题也有一系列的设计模式，比较常用的主要有Thread-Per-Message模式、Worker Thread模 式、生产者-消费者模式等等  

####   Thread-Per-Message模式
简言之就是为每个任务 分配一个独立的线程。这是一种最简单的分工方法，实现起来也非常简单。

Thread-Per-Message模式的一个最经典的应用场景是网络编程里服务端的实现，服务端为每个客户端请求创建一个独立的线
程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。  



###  轻量级线程   
这个方案在Java领域知名度并不高，但是在其他编程语言里却叫得很响，例如Go 语言、Lua语言里的协程，本质上就是一种轻量级的线程。
轻量级的线程，创建的成本很低，基本上和创建一个普通对象的成 本相似;并且创建的速度和内存占用相比操作系统线程至少有一个数量级的提升，
所以基于轻量级线程实现Thread-Per- Message模式就完全没有问题了。   

OpenJDK有个Loom项目，就是要解决Java语言的轻量级线程问题，在这 个项目中，轻量级线程被叫做Fiber。  

###  用Fiber实现Thread-Per-Message模式 
对比Thread的实现，你会发现改动量非常小，只需要把new Thread(()-> {...}).start()换成 Fiber.schedule(()->{})就可以了。   



总结
并发编程领域的分工问题，指的是如何高效地拆解任务并分配给线程。
前面我们在并发工具类模块中已经介绍了不少解决分工 问题的工具类，
例如Future、CompletableFuture 、CompletionService、Fork/Join计算框架等，
这些工具类都能很好地解决 特定应用场景的问题，所以，这些工具类曾经是Java语言引以为傲的。
不过这些工具类都继承了Java语言的老毛病:太复 杂。
如果你一直从事Java开发，估计你已经习以为常了，习惯性地认为这个复杂度是正常的。不过这个世界时刻都在变化，曾经 正常的复杂度，
现在看来也许就已经没有必要了，例如Thread-Per-Message模式如果使用线程池方案就会增加复杂度。
Thread-Per-Message模式在Java领域并不是那么知名，根本原因在于Java语言里的线程是一个重量级的对象，
为每一个任务 创建一个线程成本太高，尤其是在高并发领域，基本就不具备可行性。不过这个背景条件目前正在发生巨变，
Java语言未来 一定会提供轻量级线程，这样基于轻量级线程实现Thread-Per-Message模式就是一个非常靠谱的选择。
当然，对于一些并发度没那么高的异步场景，例如定时任务，采用Thread-Per-Message模式是完全没有问题的。
实际工作 中，我就⻅过完全基于Thread-Per-Message模式实现的分布式调度框架，这个框架为每个定时任务都分配了一个独立的线 程。



世界在变化 ， 不能保守残缺 ， 看起来go语言的学习还是有必要的
每天不断的练习算法 ，训练自己的逻辑 。
每天不挺的学习新东西 ，扩展自己的宽度和视野 。