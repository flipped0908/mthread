## 安全性

共享内存 共享变量 数据竞争  

就是多个线程会同时读写同一个数据  

（不共享数据就不会有问题）TLS 和 final  

竞态条件：程序的执行结果依赖线程的执行顺序  

解决方案：互斥 ，cpu提供了相关的指令，操作系统和变成语言提供了相关的API，
从逻辑上看同一叫做锁


## 活跃性

活锁：线程虽然没有发生阻塞，但是仍然会出现执行不下去的情况，这就是所谓的活锁。

解决方案： 尝试等待一个随机时间。Raft 这样知名的分布式一致性算法中也用到了它

  
  
饥饿：线程因无法访问所需要的资源而无法执行下去的情况。在cpu繁忙的情况下线程优先级低的执行机会小  
解决方案： 一资源充足，二 公平分配资源 ，三 避免长期持有锁  


## 性能
一 既然锁会带来性能问题，使用无锁的算法和数据结构  
TLS，写入时复制（Copy-on-write） ,乐观锁 ，java并发包里的原子类也是一种无锁的结构，
Disruptor 是一个无锁的内存队列，性能都很好  

二 减少锁持有的时间  
使用细粒度的锁， ConcurrentHashMap 中使用的分段锁技术，
还可以使用读写锁，读是无锁的，只有写的时候添加互斥锁  



性能： 吞吐量，延迟， 并发量