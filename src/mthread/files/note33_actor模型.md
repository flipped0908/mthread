
上学的时候，有⻔计算机专业课叫做面向对象编程，学这⻔课的时候有个问题困扰了我很久，按照面向对象编程的理论，对象 之间通信需要依靠消息，
而实际上，像C++、Java这些面向对象的语言，对象之间通信，依靠的是对象方法。对象方法和过程 语言里的函数本质上没有区别，有入参、有出参，
思维方式很相似，使用起来都很简单。那面向对象理论里的消息是否就等价 于面向对象语言里的对象方法呢?很⻓一段时间里，
我都以为对象方法是面向对象理论中消息的一种实现，直到接触到Actor 模型，才明白消息压根不是这个实现法。


# Hello Actor模型


# 消息和对象方法的区别

所以，在Actor模型里，发送消息仅仅是把消息发出去而已，接收消息的Actor在接收到消息后，也不一定会立即处理，
也就是 说Actor中的消息机制完全是异步的。而调用对象方法，实际上是同步的，对象方法return之前，调用方会一直等待。

除此之外，调用对象方法，需要持有对象的引用，所有的对象必须在同一个进程中。而在Actor中发送消息，类似于现实中的 写信，
只需要知道对方的地址就可以，发送消息和接收消息的Actor可以不在一个进程中，也可以不在同一台机器上。因 此，Actor模型不但适用于并发计算，还适用于分布式计算。


# Actor的规范化定义

Actor是一种
基础的计算单元，具体来讲包括三部分能力，分别是:
1. 处理能力，处理接收到的消息。
2. 存储能力，Actor可以存储自己的内部状态，并且内部状态在不同Actor之间是绝对隔离的。
3. 通信能力，Actor可以和其他Actor之间通信。



# 用Actor实现累加器



总结
Actor模型是一种非常简单的计算模型，其中Actor是最基本的计算单元，Actor之间是通过消息进行通信。Actor与面向对象编
程(OOP)中的对象匹配度非常高，在面向对象编程里，系统由类似于生物细胞那样的对象构成，对象之间也是通过消息进 行通信，所以在面向对象语言里使用Actor模型基本上不会有违和感。
在Java领域，除了可以使用Akka来支持Actor模型外，还可以使用Vert.x，不过相对来说Vert.x更像是Actor模型的隐式实现， 对应关系不像Akka那样明显，不过本质上也是一种Actor模型。
Actor可以创建新的Actor，这些Actor最终会呈现出一个树状结构，非常像现实世界里的组织结构，所以利用Actor模型来对程 序进行建模，
和现实世界的匹配度非常高。Actor模型和现实世界一样都是异步模型，理论上不保证消息百分百送达，也不保 证消息送达的顺序和发送的顺序是一致的，
甚至无法保证消息会被百分百处理。虽然实现Actor模型的厂商都在试图解决这些 问题，但遗憾的是解决得并不完美，所以使用Actor模型也是有成本的。