Worker Thread模式可以类比现实世界里⻋间的工作模式:⻋间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。
 你可以参考下面的示意图来理解，Worker Thread模式中Worker Thread对应到现实世界里，其实指的就是⻋间里的工人。
 不 过这里需要注意的是，⻋间里的工人数量往往是确定的。  
 
 
 你很容易就能想 到用阻塞队列做任务池，然后创建固定数量的线程消费阻塞队列中的任务。其实你仔细想会发现，这个方案就是Java语言提 供的线程池。
 
 
 #### 正确地创建线程池 
 Java的线程池既能够避免无限制地创建线程导致OOM，也能避免无限制地接收任务导致OOM。只不过后者经常容易被我们忽
 略，例如在上面的实现中，就被我们忽略了。所以强烈建议你用创建有界的队列来接收任务。  
 
 三点建议
 ```  
 
 ExecutorService es = new ThreadPoolExecutor( 50, 500,
 60L, TimeUnit.SECONDS,
 //注意要创建有界队列
 new LinkedBlockingQueue<Runnable>(2000), 
 //建议根据业务需求实现ThreadFactory
 r->{
 return new Thread(r, "echo-"+ r.hashCode()); },
 //建议根据业务需求实现
 RejectedExecutionHandler new ThreadPoolExecutor.CallerRunsPolicy());
 ```
 
 
 ####  避免线程死锁
 
 提交到相同线程池中的任务一定是相互独立的，否则就一定要慎重。
 
 
 ####  总结
 我们曾经说过，解决并发编程里的分工问题，最好的办法是和现实世界做对比。对比现实世界构建编程领域的模型，能够让模 型更容易理解。上一篇我们介绍的Thread-Per-Message模式，类似于现实世界里的委托他人办理，而今天介绍的Worker Thread模式则类似于⻋间里工人的工作模式。如果你在设计阶段，发现对业务模型建模之后，模型非常类似于⻋间的工作模 式，那基本上就能确定可以在实现阶段采用Worker Thread模式来实现。
 Worker Thread模式和Thread-Per-Message模式的区别有哪些呢?从现实世界的⻆度看，你委托代办人做事，往往是和代办 人直接沟通的;对应到编程领域，其实现也是主线程直接创建了一个子线程，主子线程之间是可以直接通信的。而⻋间工人的 工作方式则是完全围绕任务展开的，一个具体的任务被哪个工人执行，预先是无法知道的;对应到编程领域，则是主线程提交 任务到线程池，但主线程并不关心任务被哪个线程执行。
 Worker Thread模式能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。Java语言里可以直接使用线程池来实 现Worker Thread模式，线程池是一个非常基础和优秀的工具类，甚至有些大厂的编码规范都不允许用new Thread()来创建线 程的，必须使用线程池。
 不过使用线程池还是需要格外谨慎的，除了今天重点讲到的如何正确创建线程池、如何避免线程死锁问题，还需要注意前面我 们曾经提到的ThreadLocal内存泄露问题。同时对于提交到线程池的任务，还要做好异常处理，避免异常的任务从眼前溜走，
  
 从业务的⻆度看，有时没有发现异常的任务后果往往都很严重。