
#  高性能数据库连接池HiKariCP

本质上，数据库连接池和线程池一样， 都属于池化资源，作用都是避免重量级资源的频繁创建和销毁，对于数据库连接池来说，也就是避免数据库连接频繁创建和销 毁。

执行数据库操作基 本上是一系列规范化的步骤:
1. 通过数据源获取一个数据库连接; 
2. 创建Statement;
3. 执行SQL;
4. 通过ResultSet获取SQL执行结果;
5. 释放ResultSet;
6. 释放Statement; 
7. 释放数据库连接。


HiKariCP官方网站解释了其性能之所以如此之高的秘密。微观上HiKariCP程序编译出的字节码执行效率更高，站在字节码的 ⻆度去优化Java代码，
HiKariCP的作者对性能的执着可⻅一斑，不过遗憾的是他并没有详细解释都做了哪些优化。
而宏观上 主要是和两个数据结构有关，一个是FastList，另一个是ConcurrentBag。下面我们来看看它们是如何提升HiKariCP的性能 的。


# FastList解决了哪些性能问题

最好的办法是当关闭Connection时，能够自动关闭 Statement。

HiKariCP觉得用ArrayList还是太慢
HiKariCP中的FastList相对于ArrayList的一个优化点就是将 remove(Object element) 方法的查找顺序变成了逆序查找。
FastList还有另一个优化点，是 get(int index) 方法没有对index参数进行越界检查，HiKariCP能保证不会越 界，所以不用每次都进行越界检查。


#  ConcurrentBag解决了哪些性能问题

如果让我们自己来实现一个数据库连接池，最简单的办法就是用两个阻塞队列来实现，一个用于保存空闲数据库连接的队列 idle，
另一个用于保存忙碌数据库连接的队列busy;获取连接时将空闲的数据库连接从idle队列移动到busy队列，
而关闭连接 时将数据库连接从busy移动到idle。这种方案将并发问题委托给了阻塞队列，实现简单，但是性能并不是很理想。
因为Java SDK中的阻塞队列是用锁实现的，而高并发场景下锁的争用对性能影响很大。


HiKariCP并没有使用Java SDK中的阻塞队列，而是自己实现了一个叫做ConcurrentBag的并发容器。
ConcurrentBag的设计最 初源自C#，它的一个核心设计是使用ThreadLocal避免部分并发问题，
不过HiKariCP中的ConcurrentBag并没有完全参考C#的 实现，下面我们来看看它是如何实现的。


ConcurrentBag中最关键的属性有4个，分别是:用于存储所有的数据库连接的共享队列sharedList、线程本地存储 threadList、等待数据库连接的线程数waiters以及分配数据库连接的工具handoffQueue。


通过ConcurrentBag提供的borrow()方法，可以获取一个空闲的数据库连接，borrow()的主要逻辑是:
1. 首先查看线程本地存储是否有空闲连接，如果有，则返回一个空闲的连接; 2. 如果线程本地存储中无空闲连接，则从共享队列中获取。
3. 如果共享队列中也没有空闲的连接，则请求线程需要等待。
需要注意的是，线程本地存储中的连接是可以被其他线程窃取的，所以需要用CAS方法防止重复分配。在共享队列中获取空闲 连接，也采用了CAS方法防止重复分配。




# 总结
HiKariCP中的FastList和ConcurrentBag这两个数据结构使用得非常巧妙，虽然实现起来并不复杂，但是对于性能的提升非常 明显，根本原因在于这两个数据结构适用于数据库连接池这个特定的场景。
FastList适用于逆序删除场景;而ConcurrentBag 通过ThreadLocal做一次预分配，避免直接竞争共享资源，非常适合池化资源的分配。

在实际工作中，我们遇到的并发问题千差万别，这时选择合适的并发数据结构就非常重要了。当然能选对的前提是对特定场景 的并发特性有深入的了解，只有了解到无谓的性能消耗在哪里，才能对症下药。

欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也 欢迎把它分享给更多的朋友。









































