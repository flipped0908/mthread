# Token Bucke

首先我们来看看Guava RateLimiter是如何解决高并发场景下的限流问题的

Guava的限流器使用上还是很简单的，那它是如何实现的呢?Guava采用的是令牌桶算法，其核心是要想通过限流器，必须拿  
到令牌。也就是说，只要我们能够限制发放令牌的速率，那么就能控制流速了。


令牌桶算法的详细描述如下:  
1. 令牌以固定的速率添加到令牌桶中，假设限流的速率是 r/秒，则令牌每 1/r 秒会添加一个; 2. 假设令牌桶的容量是 b ，如果令牌桶已满，则新的令牌会被丢弃;  
3. 请求能够通过限流器的前提是令牌桶中有令牌。  
这个算法中，限流的速率 r 还是比较容易理解的，但令牌桶的容量 b 该怎么理解呢?b 其实是burst的简写，意义是限流器允许 的最大突发流量。  
比如b=10，而且令牌桶中的令牌已满，此时限流器允许10个请求同时通过限流器，当然只是突发流量而 已，这10个请求会带走10个令牌，所以后续的流量只能按照速率 r 通过限流器。



可实际情况却是使用限流的 场景大部分都是高并发场景，而且系统压力已经临近极限了，此时这个实现就有问题了。
问题就出在定时器上，在高并发场景 下，当系统压力已经临近极限的时候，定时器的精度误差会非常大，同时定时器本身会创建调度线程，也会对系统的性能产生 影响。
那还有什么好的实现方式呢?当然有，Guava的实现就没有使用定时器，下面我们就来看看它是如何实现的。